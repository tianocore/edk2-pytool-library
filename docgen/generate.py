# @file generate.py
# Generates the documentation for this repo
#
#
# Copyright (c) Microsoft Corporation
#
# SPDX-License-Identifier: BSD-2-Clause-Patent
##
import os
import sys
import argparse
import glob
import logging
import yaml
import shutil
from edk2toollib import utility_functions
import mako.exceptions
from mike import commands as mike_commands
import mkdocs.config as mkdocs_config
import mkdocs.exceptions as _mkdocs_exceptions
from mkdocs.commands.build import build as mkdocs_build
from pdocs import as_markdown as pdocs_as_markdown

project_config = {
    "site_name": "Project Mu",
    "repo_url": "https://github.com/microsoft/mu",
    "copyright": "Copyright (c) Microsoft.  All rights reserved",
    "site_description": "Project Mu Documentation",
    "site_url": 'https://microsoft.github.io/mu/',
    "plugins": ["search", ],  # "macros"],

    "theme": {
        "name": 'material',
        "palette": {
            "primary": 'indigo',
            "accent": 'indigo'
        }
    },
    "markdown_extensions": [
        "admonition",
        "codehilite",
        "meta",
        {
            "pymdownx.betterem": {
                "smart_enable": "all",
            },
        },
        "pymdownx.caret",
        "pymdownx.critic",
        "pymdownx.details",
        {
            "pymdownx.emoji": {
                "emoji_generator": "!!python / name: pymdownx.emoji.to_png",
            },
        },
        "pymdownx.inlinehilite",
        "pymdownx.magiclink",
        "pymdownx.mark",
        "pymdownx.smartsymbols",
        "pymdownx.superfences",
        {
            "pymdownx.tasklist": {
                "custom_checkbox": True,
            },
        },
        "pymdownx.tilde",
        {
            "toc": {
                "permalink": True,
            }
        },
        "markdown.extensions.abbr",
        "markdown.extensions.admonition",
        "markdown.extensions.attr_list",
        "markdown.extensions.def_list",
        "markdown.extensions.fenced_code",
        "markdown.extensions.footnotes",
        "markdown.extensions.tables",
        "markdown.extensions.smarty",
        "markdown.extensions.toc",
    ],
    "nav": [
        {
            "Home": "readme.md"
        }
    ]
}
'''

nav:
    - Home: 'index.md'
    - What and Why:
        - Overview: 'WhatAndWhy/overview.md'
        - Dependencies and Layout: 'WhatAndWhy/layout.md'
        - Features: 'WhatAndWhy/features.md'
    - Where:
        - Project Resources: 'Where/project_resources.md'
        - External Resources: 'Where/external_resources.md'
    - How:
        - Release Process: 'How/release_process.md'
        - Contributing: 'How/contributing.md'
        - Using: 'How/using_project_mu.md'
    - Developing Docs:
        - Overview: "DeveloperDocs/developer_docs.md"
        - How To Build: "DeveloperDocs/build_community_docs.md"
        - Sample Syntax: "DeveloperDocs/doc_sample_test.md"
        - Doc Framework Attribution: "DeveloperDocs/attribution.md"
        - Documentation Requirements: "DeveloperDocs/requirements.md"
    - Developing Code:
        - Overview: "CodeDevelopment/overview.md"
        - Tools and Prerequisite: "CodeDevelopment/prerequisites.md"
        - Compiling: "CodeDevelopment/compile.md"
        - Testing: "CodeDevelopment/test.md"
        - Code Requirements: "CodeDevelopment/requirements.md"
    - FAQ: 'faq.md'
    - License: 'license.md'
    # AUTOGENERATED CONTENT WILL BE ADDED HERE
'''


#
# When generating the nav convert visible names
# to something more human readable
#
# Currently support changing snake_case and CamelCase
#
def ConvertToFriendlyName(self, string):
    string = string.replace("_", " ").strip()  # strip snake case
    string = ' '.join(string.split())  # strip duplicate spaces

    # Handle camel case
    newstring = ""
    prev_char_lowercase = False
    for i in string:
        if(not prev_char_lowercase):
            newstring += i
        else:
            if(i.isupper()):
                newstring += " " + i
            else:
                newstring += i
        prev_char_lowercase = i.islower()

    return newstring


def parse_arguments():
    parser = argparse.ArgumentParser(description="Generates the python documentation")
    '''
    Manual: A user manually queued the build.
    IndividualCI: Continuous integration (CI) triggered by a Git push or a TFVC check-in.
    BatchedCI: Continuous integration (CI) triggered by a Git push or a TFVC check-in, and the Batch changes was selected.
    Schedule: Scheduled trigger.
    ValidateShelveset: A user manually queued the build of a specific TFVC shelveset.
    CheckInShelveset: Gated check-in trigger.
    PullRequest: The build was triggered by a Git branch policy that requires a build.
    BuildCompletion: The build was triggered by another build.
    ResourceTrigger: The build was triggered by a resource trigger.
    '''
    parser.add_argument("--reason", "-r", type=str, dest="reason", default="Manual")
    parser.add_argument("--workspace", "-ws", type=str, dest="ws", default=os.getcwd())
    parser.add_argument("--output_dir", "-o", type=str, dest="output_dir", default="doc_output")
    parser.add_argument("--module", "-m", type=str, dest="module")
    parser.add_argument("--docs", "-d", type=str, dest="src_docs", action='append')
    parser.add_argument("--serve", "-s", dest="serve", default=False, action='store_true')
    parser.add_argument("--verbose", "-v", dest="verbose", action="store_true", default=False)
    options = parser.parse_args()
    valid_reasons = ['Manual', 'IndividualCI', 'BatchedCI', 'Schedule', 'ValidateShelveset',
                     'CheckInShelveset', 'PullRequest', 'BuildCompletion', 'ResourceTrigger', ]
    options = vars(options)
    if options["reason"] not in valid_reasons:
        logging.error(f"{options['reason']} is not a valid reason")
        sys.exit(1)
    if options["module"] is None:
        # TODO figure out what module we are in?
        options["module"] = "edk2toollib"
    ws = options["ws"]
    options["output_dir"] = os.path.abspath(os.path.join(ws, options["output_dir"]))
    options["html_dir"] = os.path.abspath(os.path.join(options["output_dir"], "html"))
    options["docs_dir"] = os.path.abspath(os.path.join(options["output_dir"], "docs"))
    shutil.rmtree(options["output_dir"], ignore_errors=True)
    os.makedirs(options["output_dir"], exist_ok=True)
    os.makedirs(options["html_dir"], exist_ok=True)
    os.makedirs(options["docs_dir"], exist_ok=True)
    return options


def generate_config_file(options):

    config_path = os.path.join(options["output_dir"], "mkdocs.yml")
    project_config["docs_dir"] = options["docs_dir"]
    project_config["site_dir"] = options["html_dir"]
    with open(config_path, "w") as yaml_file:
        yaml.dump(project_config, yaml_file)  # , default_flow_style=False)
    if options["verbose"]:
        print(f"Generating config file {config_path}")
    mike_commands.install_extras(config_path)
    return config_path


def generate_pdoc_markdown(options):
    pdocs_as_markdown([options["module"], ], options["docs_dir"], overwrite=True)


def run_mkdocs(options):
    config_instance = mkdocs_config.Config(schema=mkdocs_config.DEFAULT_SCHEMA)
    project_config["config_file_path"] = generate_config_file(options)
    config_instance.load_dict(project_config)

    errors, warnings = config_instance.validate()
    if errors:
        print(errors)
        raise _mkdocs_exceptions.ConfigurationError(
            f"Aborted with {len(errors)} Configuration Errors!"
        )
    if warnings and options["verbose"]:  # pragma: no cover
        print(warnings)
        raise _mkdocs_exceptions.ConfigurationError(
            f"Aborted with {len(warnings)} Configuration Warnings in 'strict' mode!"
        )
    return mkdocs_build(config_instance)


def copy_docs(options):
    # first copy the readme if needed
    root_files = ["readme.md", "license.txt"]
    for root_filename in root_files:
        root_infile = os.path.join(options["ws"], root_filename)
        root_outfile = os.path.join(options["docs_dir"], root_filename)
        if os.path.exists(root_infile):
            shutil.copy2(root_infile, root_outfile)
    
    def handle_glob(glob_iter, src_folder, dst_folder):
        for doc in glob_iter:
            rel_path = os.path.relpath(doc, src_folder)
            rel_dir = os.path.dirname(rel_path)
            output_dir = os.path.join(dst_folder, rel_dir)
            outfile = os.path.join(output_dir, os.path.basename(doc))
            os.makedirs(output_dir, exist_ok=True)
            if os.path.exists(outfile):
                logging.warning(f"Overwritting {outfile}")
                raise ValueError()
            shutil.copy2(doc, outfile)
    # copy any files from the code tree
    module_path = os.path.join(options["ws"], options["module"])
    if os.path.exists(module_path):
        search_path = os.path.join(module_path, "**", "*.md")
        docs = glob.iglob(search_path, recursive=True)
        handle_glob(docs, options["ws"], options["docs_dir"])
    
    # copy any doc folders
    if options["src_docs"] == None:
        return
    for src_folder in options["src_docs"]:
        src_folder = os.path.join(options["ws"], src_folder)
        if not os.path.exists(src_folder):
            raise ValueError(f"Bad path: {src_folder}")
        search_path = os.path.join(src_folder, "**", "*.md")
        docs = glob.iglob(search_path, recursive=True)
        handle_glob(docs, src_folder, options["docs_dir"])

def generate_nav(options):
    pass


def serve_docs(options):
    if options["serve"]:
        print("Serving your project. Press Ctrl-C to exit")
        mike_commands.serve(verbose=True)

def deploy(options):
    print(mike_commands.list_versions())
    mike_commands.deploy(options["html_dir"], 1.0, branch="personal/macarl/add-docs")


def main():
    options = parse_arguments()
    logging.critical("Generating Python documentation")
    generate_pdoc_markdown(options)
    logging.critical("Copying existing documentation")
    copy_docs(options)
    logging.critical("Generating Navigation")
    generate_nav(options)
    logging.critical("Converting to HTML")
    run_mkdocs(options)
    logging.critical("Deploying")
    deploy(options)
    logging.critical("Serving")
    serve_docs(options)


if __name__ == "__main__":
    main()
